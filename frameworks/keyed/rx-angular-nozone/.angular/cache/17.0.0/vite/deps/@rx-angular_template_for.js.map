{
  "version": 3,
  "sources": ["../../../../../node_modules/@rx-angular/cdk/fesm2022/cdk-coercing.mjs", "../../../../../node_modules/@rx-angular/cdk/fesm2022/cdk-internals-scheduler.mjs", "../../../../../node_modules/@rx-angular/cdk/fesm2022/rx-angular-cdk-coalescing.mjs", "../../../../../node_modules/@rx-angular/cdk/fesm2022/cdk-internals-core.mjs", "../../../../../node_modules/@rx-angular/cdk/fesm2022/cdk-render-strategies.mjs", "../../../../../node_modules/@rx-angular/cdk/fesm2022/cdk-template.mjs", "../../../../../node_modules/@rx-angular/template/fesm2022/template-for.mjs"],
  "sourcesContent": ["import { isObservable, of, Subject } from 'rxjs';\nimport { map, switchAll, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * This Observable factory creates an Observable out of a static value or an Observable.\n *\n * @param o - the value to coerce\n */\nfunction coerceObservable(o) {\n    return isObservable(o) ? o : of(o);\n}\n\n/**\n * This operator maps an Observable out of a static value or an Observable.\n *\n */\nfunction coerceObservableWith() {\n    return (o$) => map(coerceObservable)(o$);\n}\n\n/**\n * This Observable factory creates an Observable out of a static value or an Observable.\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param o$ - The Observable to coerce and map to a Observable with distinct values\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n */\nfunction coerceDistinctObservable(o$, flattenOperator) {\n    flattenOperator = flattenOperator || switchAll();\n    return coerceObservable(o$).pipe(distinctUntilChanged(), flattenOperator, distinctUntilChanged());\n}\n\n/**\n * This operator takes an Observable of values ot Observables aof values and\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n *\n */\nfunction coerceDistinctWith(flattenOperator) {\n    flattenOperator = flattenOperator || switchAll();\n    return (o$) => o$.pipe(coerceObservableWith(), distinctUntilChanged(), flattenOperator, distinctUntilChanged());\n}\n\n/**\n * A factory function returning an object to handle the process of merging Observable next notifications into one\n *   Observable. This API takes away the clumsy handling of static values and Observable, reduces the number of\n *   emissions by:\n * - only merging distinct Observables\n * - only emit distinct values of the merged result\n *\n * You can next a Observable of `U` multiple times and merge them into the Observable exposed under one optimized\n *   `values$`\n *\n */\nfunction coerceAllFactory(subjectFactory, flattenOperator) {\n    const observablesSubject = subjectFactory ? subjectFactory() : new Subject();\n    flattenOperator = flattenOperator || switchAll();\n    const values$ = observablesSubject.pipe(coerceDistinctWith(flattenOperator));\n    return {\n        next(observable) {\n            observablesSubject.next(observable);\n        },\n        values$,\n    };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { coerceAllFactory, coerceDistinctObservable, coerceDistinctWith, coerceObservable, coerceObservableWith };\n\n", "import { ɵglobal } from '@angular/core';\n\nfunction push(heap, node) {\n    const index = heap.length;\n    heap.push(node);\n    siftUp(heap, node, index);\n}\nfunction peek(heap) {\n    const first = heap[0];\n    return first === undefined ? null : first;\n}\nfunction pop(heap) {\n    const first = heap[0];\n    if (first !== undefined) {\n        const last = heap.pop();\n        if (last !== first) {\n            heap[0] = last;\n            siftDown(heap, last, 0);\n        }\n        return first;\n    }\n    else {\n        return null;\n    }\n}\nfunction siftUp(heap, node, i) {\n    let index = i;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const parentIndex = (index - 1) >>> 1;\n        const parent = heap[parentIndex];\n        if (parent !== undefined && compare(parent, node) > 0) {\n            // The parent is larger. Swap positions.\n            heap[parentIndex] = node;\n            heap[index] = parent;\n            index = parentIndex;\n        }\n        else {\n            // The parent is smaller. Exit.\n            return;\n        }\n    }\n}\nfunction siftDown(heap, node, i) {\n    let index = i;\n    const length = heap.length;\n    while (index < length) {\n        const leftIndex = (index + 1) * 2 - 1;\n        const left = heap[leftIndex];\n        const rightIndex = leftIndex + 1;\n        const right = heap[rightIndex];\n        // If the left or right node is smaller, swap with the smaller of those.\n        if (left !== undefined && compare(left, node) < 0) {\n            if (right !== undefined && compare(right, left) < 0) {\n                heap[index] = right;\n                heap[rightIndex] = node;\n                index = rightIndex;\n            }\n            else {\n                heap[index] = left;\n                heap[leftIndex] = node;\n                index = leftIndex;\n            }\n        }\n        else if (right !== undefined && compare(right, node) < 0) {\n            heap[index] = right;\n            heap[rightIndex] = node;\n            index = rightIndex;\n        }\n        else {\n            // Neither child is smaller. Exit.\n            return;\n        }\n    }\n}\nfunction compare(a, b) {\n    // Compare sort index first, then task id.\n    const diff = a.sortIndex - b.sortIndex;\n    return diff !== 0 ? diff : a.id - b.id;\n}\n\n// see https://github.com/facebook/react/blob/main/packages/scheduler/src/forks/Scheduler.js\nlet getCurrentTime;\nconst hasPerformanceNow = typeof ɵglobal.performance === 'object' &&\n    typeof ɵglobal.performance.now === 'function';\nif (hasPerformanceNow) {\n    const localPerformance = ɵglobal.performance;\n    getCurrentTime = () => localPerformance.now();\n}\nelse {\n    const localDate = Date;\n    const initialTime = localDate.now();\n    getCurrentTime = () => localDate.now() - initialTime;\n}\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nconst maxSigned31BitInt = 1073741823;\n// Times out immediately\nconst IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nconst USER_BLOCKING_PRIORITY_TIMEOUT = 250;\nconst NORMAL_PRIORITY_TIMEOUT = 5000;\nconst LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\nconst IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;\n// Tasks are stored on a min heap\nconst taskQueue = [];\nconst timerQueue = [];\n// Incrementing id counter. Used to maintain insertion order.\nlet taskIdCounter = 1;\n// Pausing the scheduler is useful for debugging.\nlet isSchedulerPaused = false;\nlet currentTask = null;\nlet currentPriorityLevel = 3 /* PriorityLevel.NormalPriority */;\n// This is set while performing work, to prevent re-entrancy.\nlet isPerformingWork = false;\nlet isHostCallbackScheduled = false;\nlet isHostTimeoutScheduled = false;\n// Capture local references to native APIs, in case a polyfill overrides them.\nconst setTimeout = ɵglobal.setTimeout;\nconst clearTimeout = ɵglobal.clearTimeout;\nconst setImmediate = ɵglobal.setImmediate; // IE and Node.js + jsdom\nconst messageChannel = ɵglobal.MessageChannel;\nconst isInputPending = typeof ɵglobal.navigator !== 'undefined' &&\n    ɵglobal.navigator.scheduling !== undefined &&\n    ɵglobal.navigator.scheduling.isInputPending !== undefined\n    ? ɵglobal.navigator.scheduling.isInputPending.bind(ɵglobal.navigator.scheduling)\n    : null;\nconst defaultZone = {\n    run: (fn) => fn(),\n};\nfunction advanceTimers(currentTime) {\n    // Check for tasks that are no longer delayed and add them to the queue.\n    let timer = peek(timerQueue);\n    while (timer !== null) {\n        if (timer.callback === null) {\n            // Timer was cancelled.\n            pop(timerQueue);\n        }\n        else if (timer.startTime <= currentTime) {\n            // Timer fired. Transfer to the task queue.\n            pop(timerQueue);\n            timer.sortIndex = timer.expirationTime;\n            push(taskQueue, timer);\n        }\n        else {\n            // Remaining timers are pending.\n            return;\n        }\n        timer = peek(timerQueue);\n    }\n}\nfunction handleTimeout(currentTime) {\n    isHostTimeoutScheduled = false;\n    advanceTimers(currentTime);\n    if (!isHostCallbackScheduled) {\n        if (peek(taskQueue) !== null) {\n            isHostCallbackScheduled = true;\n            requestHostCallback(flushWork);\n        }\n        else {\n            const firstTimer = peek(timerQueue);\n            if (firstTimer !== null) {\n                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n            }\n        }\n    }\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n    // We'll need a host callback the next time work is scheduled.\n    isHostCallbackScheduled = false;\n    if (isHostTimeoutScheduled) {\n        // We scheduled a timeout but it's no longer needed. Cancel it.\n        isHostTimeoutScheduled = false;\n        cancelHostTimeout();\n    }\n    isPerformingWork = true;\n    const previousPriorityLevel = currentPriorityLevel;\n    try {\n        return workLoop(hasTimeRemaining, initialTime);\n    }\n    finally {\n        currentTask = null;\n        currentPriorityLevel = previousPriorityLevel;\n        isPerformingWork = false;\n    }\n}\nfunction workLoop(hasTimeRemaining, initialTime, _currentTask) {\n    let currentTime = initialTime;\n    if (_currentTask) {\n        currentTask = _currentTask;\n    }\n    else {\n        advanceTimers(currentTime);\n        currentTask = peek(taskQueue);\n    }\n    let zoneChanged = false;\n    const hitDeadline = () => currentTask &&\n        currentTask.expirationTime > currentTime &&\n        (!hasTimeRemaining || shouldYieldToHost());\n    if (!hitDeadline()) {\n        const ngZone = currentTask.ngZone || defaultZone;\n        ngZone.run(() => {\n            while (currentTask !== null && !zoneChanged) {\n                if (hitDeadline()) {\n                    break;\n                }\n                const callback = currentTask.callback;\n                if (typeof callback === 'function') {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n                    const continuationCallback = callback(didUserCallbackTimeout);\n                    currentTime = getCurrentTime();\n                    if (typeof continuationCallback === 'function') {\n                        currentTask.callback = continuationCallback;\n                    }\n                    else {\n                        if (currentTask === peek(taskQueue)) {\n                            pop(taskQueue);\n                        }\n                    }\n                    advanceTimers(currentTime);\n                }\n                else {\n                    pop(taskQueue);\n                }\n                currentTask = peek(taskQueue);\n                zoneChanged =\n                    currentTask?.ngZone != null && currentTask.ngZone !== ngZone;\n            }\n        });\n    }\n    // we need to check if leaving `NgZone` (tick => detectChanges) caused other\n    // directives to add tasks to the queue. If there is one and we still didn't\n    // hit the deadline, run the workLoop again in order to flush everything thats\n    // left.\n    // Otherwise, newly added tasks won't run as `performingWork` is still `true`\n    currentTask = currentTask ?? peek(taskQueue);\n    // We should also re-calculate the currentTime, as we need to account for the execution\n    // time of the NgZone tasks as well.\n    // If there is still a task in the queue, but no time is left for executing it,\n    // the scheduler will re-schedule the next tick anyway\n    currentTime = getCurrentTime();\n    if (zoneChanged || (currentTask && !hitDeadline())) {\n        return workLoop(hasTimeRemaining, currentTime, currentTask);\n    }\n    // Return whether there's additional work\n    if (currentTask !== null) {\n        return true;\n    }\n    else {\n        const firstTimer = peek(timerQueue);\n        if (firstTimer !== null) {\n            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n        }\n        return false;\n    }\n}\nfunction runWithPriority(priorityLevel, eventHandler) {\n    switch (priorityLevel) {\n        case 1 /* PriorityLevel.ImmediatePriority */:\n        case 2 /* PriorityLevel.UserBlockingPriority */:\n        case 3 /* PriorityLevel.NormalPriority */:\n        case 4 /* PriorityLevel.LowPriority */:\n        case 5 /* PriorityLevel.IdlePriority */:\n            break;\n        default:\n            priorityLevel = 3 /* PriorityLevel.NormalPriority */;\n    }\n    const previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = priorityLevel;\n    try {\n        return eventHandler();\n    }\n    finally {\n        currentPriorityLevel = previousPriorityLevel;\n    }\n}\nfunction next(eventHandler) {\n    let priorityLevel;\n    switch (currentPriorityLevel) {\n        case 1 /* PriorityLevel.ImmediatePriority */:\n        case 2 /* PriorityLevel.UserBlockingPriority */:\n        case 3 /* PriorityLevel.NormalPriority */:\n            // Shift down to normal priority\n            priorityLevel = 3 /* PriorityLevel.NormalPriority */;\n            break;\n        default:\n            // Anything lower than normal priority should remain at the current level.\n            priorityLevel = currentPriorityLevel;\n            break;\n    }\n    const previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = priorityLevel;\n    try {\n        return eventHandler();\n    }\n    finally {\n        currentPriorityLevel = previousPriorityLevel;\n    }\n}\nfunction wrapCallback(callback) {\n    const parentPriorityLevel = currentPriorityLevel;\n    return () => {\n        // This is a fork of runWithPriority, inlined for performance.\n        const previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n            // eslint-disable-next-line prefer-rest-params\n            return callback.apply(this, arguments);\n        }\n        finally {\n            currentPriorityLevel = previousPriorityLevel;\n        }\n    };\n}\nfunction scheduleCallback(priorityLevel, callback, options) {\n    const currentTime = getCurrentTime();\n    let startTime;\n    if (typeof options === 'object' && options !== null) {\n        const delay = options.delay;\n        if (typeof delay === 'number' && delay > 0) {\n            startTime = currentTime + delay;\n        }\n        else {\n            startTime = currentTime;\n        }\n    }\n    else {\n        startTime = currentTime;\n    }\n    let timeout;\n    switch (priorityLevel) {\n        case 1 /* PriorityLevel.ImmediatePriority */:\n            timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n            break;\n        case 2 /* PriorityLevel.UserBlockingPriority */:\n            timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n            break;\n        case 5 /* PriorityLevel.IdlePriority */:\n            timeout = IDLE_PRIORITY_TIMEOUT;\n            break;\n        case 4 /* PriorityLevel.LowPriority */:\n            timeout = LOW_PRIORITY_TIMEOUT;\n            break;\n        case 3 /* PriorityLevel.NormalPriority */:\n        default:\n            timeout = NORMAL_PRIORITY_TIMEOUT;\n            break;\n    }\n    const expirationTime = startTime + timeout;\n    const newTask = {\n        id: taskIdCounter++,\n        callback,\n        priorityLevel,\n        startTime,\n        expirationTime,\n        sortIndex: -1,\n        ngZone: options?.ngZone || null,\n    };\n    if (startTime > currentTime) {\n        // This is a delayed task.\n        newTask.sortIndex = startTime;\n        push(timerQueue, newTask);\n        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n            // All tasks are delayed, and this is the task with the earliest delay.\n            if (isHostTimeoutScheduled) {\n                // Cancel an existing timeout.\n                cancelHostTimeout();\n            }\n            else {\n                isHostTimeoutScheduled = true;\n            }\n            // Schedule a timeout.\n            requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n    }\n    else {\n        newTask.sortIndex = expirationTime;\n        push(taskQueue, newTask);\n        // Schedule a host callback, if needed. If we're already performing work,\n        // wait until the next time we yield.\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n            isHostCallbackScheduled = true;\n            requestHostCallback(flushWork);\n        }\n    }\n    return newTask;\n}\nfunction pauseExecution() {\n    isSchedulerPaused = true;\n}\nfunction continueExecution() {\n    isSchedulerPaused = false;\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n        isHostCallbackScheduled = true;\n        requestHostCallback(flushWork);\n    }\n}\nfunction getFirstCallbackNode() {\n    return peek(taskQueue);\n}\nfunction cancelCallback(task) {\n    // Null out the callback to indicate the task has been canceled. (Can't\n    // remove from the queue because you can't remove arbitrary nodes from an\n    // array based heap, only the first one.)\n    task.callback = null;\n}\nfunction getCurrentPriorityLevel() {\n    return currentPriorityLevel;\n}\nlet isMessageLoopRunning = false;\nlet scheduledHostCallback = null;\nlet taskTimeoutID = -1;\n// Scheduler periodically yields in case there is other work on the main\n// thread, like user events. By default, it yields multiple times per frame.\n// It does not attempt to align with frame boundaries, since most tasks don't\n// need to be frame aligned; for those that do, use requestAnimationFrame.\nlet yieldInterval = 16;\n// TODO: Make this configurable\n// TODO: Adjust this based on priority?\nconst maxYieldInterval = 300;\nlet needsPaint = false;\nlet queueStartTime = -1;\nfunction shouldYieldToHost() {\n    if (needsPaint) {\n        // There's a pending paint (signaled by `requestPaint`). Yield now.\n        return true;\n    }\n    const timeElapsed = getCurrentTime() - queueStartTime;\n    if (timeElapsed < yieldInterval) {\n        // The main thread has only been blocked for a really short amount of time;\n        // smaller than a single frame. Don't yield yet.\n        return false;\n    }\n    // The main thread has been blocked for a non-negligible amount of time. We\n    // may want to yield control of the main thread, so the browser can perform\n    // high priority tasks. The main ones are painting and user input. If there's\n    // a pending paint or a pending input, then we should yield. But if there's\n    // neither, then we can yield less often while remaining responsive. We'll\n    // eventually yield regardless, since there could be a pending paint that\n    // wasn't accompanied by a call to `requestPaint`, or other main thread tasks\n    // like network events.\n    // we don't support isInputPending currently\n    /*if (enableIsInputPending) {\n      if (needsPaint) {\n        // There's a pending paint (signaled by `requestPaint`). Yield now.\n        return true;\n      }\n      if (timeElapsed < continuousInputInterval) {\n        // We haven't blocked the thread for that long. Only yield if there's a\n        // pending discrete input (e.g. click). It's OK if there's pending\n        // continuous input (e.g. mouseover).\n        if (isInputPending !== null) {\n          return isInputPending();\n        }\n      } else if (timeElapsed < maxInterval) {\n        // Yield if there's either a pending discrete or continuous input.\n        if (isInputPending !== null) {\n          return isInputPending(continuousOptions);\n        }\n      } else {\n        // We've blocked the thread for a long time. Even if there's no pending\n        // input, there may be some other scheduled work that we don't know about,\n        // like a network event. Yield now.\n        return true;\n      }\n    }*/\n    // `isInputPending` isn't available. Yield now.\n    return true;\n}\nfunction requestPaint() {\n    needsPaint = true;\n    // we don't support isInputPending currently\n    /*if (\n      enableIsInputPending &&\n      navigator !== undefined &&\n      (navigator as any).scheduling !== undefined &&\n      (navigator as any).scheduling.isInputPending !== undefined\n    ) {\n      needsPaint = true;\n    }*/\n}\nfunction forceFrameRate(fps) {\n    if (fps < 0 || fps > 125) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            console.error('forceFrameRate takes a positive int between 0 and 125, ' +\n                'forcing frame rates higher than 125 fps is not supported');\n        }\n        return;\n    }\n    if (fps > 0) {\n        yieldInterval = Math.floor(1000 / fps);\n    }\n    else {\n        // reset the framerate\n        yieldInterval = 5;\n    }\n    // be aware of browser housekeeping work (~6ms per frame)\n    // according to https://developers.google.com/web/fundamentals/performance/rendering\n    yieldInterval = Math.max(5, yieldInterval - 6);\n}\nconst performWorkUntilDeadline = () => {\n    if (scheduledHostCallback !== null) {\n        const currentTime = getCurrentTime();\n        // Yield after `yieldInterval` ms, regardless of where we are in the vsync\n        // cycle. This means there's always time remaining at the beginning of\n        // the message event.\n        queueStartTime = currentTime;\n        const hasTimeRemaining = true;\n        // If a scheduler task throws, exit the current browser task so the\n        // error can be observed.\n        //\n        // Intentionally not using a try-catch, since that makes some debugging\n        // techniques harder. Instead, if `scheduledHostCallback` errors, then\n        // `hasMoreWork` will remain true, and we'll continue the work loop.\n        let hasMoreWork = true;\n        try {\n            hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n        }\n        finally {\n            if (hasMoreWork) {\n                // If there's more work, schedule the next message event at the end\n                // of the preceding one.\n                schedulePerformWorkUntilDeadline();\n            }\n            else {\n                isMessageLoopRunning = false;\n                scheduledHostCallback = null;\n            }\n        }\n    }\n    else {\n        isMessageLoopRunning = false;\n    }\n    // Yielding to the browser will give it a chance to paint, so we can\n    // reset this.\n    needsPaint = false;\n};\nlet schedulePerformWorkUntilDeadline;\nif (typeof setImmediate === 'function') {\n    // Node.js and old IE.\n    // There's a few reasons for why we prefer setImmediate.\n    //\n    // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n    // (Even though this is a DOM fork of the Scheduler, you could get here\n    // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n    // https://github.com/facebook/react/issues/20756\n    //\n    // But also, it runs earlier which is the semantic we want.\n    // If other browsers ever implement it, it's better to use it.\n    // Although both of these would be inferior to native scheduling.\n    schedulePerformWorkUntilDeadline = () => {\n        setImmediate(performWorkUntilDeadline);\n    };\n}\nelse if (typeof messageChannel !== 'undefined') {\n    const channel = new messageChannel();\n    const port = channel.port2;\n    channel.port1.onmessage = performWorkUntilDeadline;\n    schedulePerformWorkUntilDeadline = () => {\n        port.postMessage(null);\n    };\n}\nelse {\n    // We should only fallback here in non-browser environments.\n    schedulePerformWorkUntilDeadline = () => {\n        setTimeout(performWorkUntilDeadline, 0);\n    };\n}\nfunction requestHostCallback(callback) {\n    scheduledHostCallback = callback;\n    if (!isMessageLoopRunning) {\n        isMessageLoopRunning = true;\n        schedulePerformWorkUntilDeadline();\n    }\n}\nfunction requestHostTimeout(callback, ms) {\n    taskTimeoutID = setTimeout(() => {\n        callback(getCurrentTime());\n    }, ms);\n}\nfunction cancelHostTimeout() {\n    clearTimeout(taskTimeoutID);\n    taskTimeoutID = -1;\n}\nconst _requestPaint = requestPaint;\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { cancelCallback, forceFrameRate, scheduleCallback };\n\n", "import { Subscription, Observable } from 'rxjs';\n\nconst coalescingManager = createCoalesceManager();\nfunction hasKey(ctx, property) {\n    return ctx[property] != null;\n}\n/*\n * createPropertiesWeakMap\n *\n * @param getDefaults: (o: O) => P\n * Example:\n *\n * export interface Properties {\n *   isCoalescing: boolean;\n * }\n *\n * const obj: object = {\n *   foo: 'bar',\n *   isCoalescing: 'weakMap version'\n * };\n *\n * const getDefaults = (ctx: object): Properties => ({isCoalescing: false});\n * const propsMap = createPropertiesWeakMap<object, Properties>(getDefaults);\n *\n * console.log('obj before:', obj);\n * // {foo: \"bar\", isCoalescing: \"weakMap version\"}\n * console.log('props before:', propsMap.getProps(obj));\n * // {isCoalescing: \"weakMap version\"}\n *\n * propsMap.setProps(obj, {isCoalescing: true});\n * console.log('obj after:', obj);\n * // {foo: \"bar\", isCoalescing: \"weakMap version\"}\n * console.log('props after:', propsMap.getProps(obj));\n * // {isCoalescing: \"true\"}\n * */\nfunction createPropertiesWeakMap(getDefaults) {\n    const propertyMap = new WeakMap();\n    return {\n        getProps: getProperties,\n        setProps: setProperties,\n    };\n    function getProperties(ctx) {\n        const defaults = getDefaults(ctx);\n        const propertiesPresent = propertyMap.get(ctx);\n        let properties;\n        if (propertiesPresent !== undefined) {\n            properties = propertiesPresent;\n        }\n        else {\n            properties = {};\n            Object.entries(defaults).forEach(([prop, value]) => {\n                if (hasKey(ctx, prop)) {\n                    properties[prop] = ctx[prop];\n                }\n                else {\n                    properties[prop] = value;\n                }\n            });\n            propertyMap.set(ctx, properties);\n        }\n        return properties;\n    }\n    function setProperties(ctx, props) {\n        const properties = getProperties(ctx);\n        Object.entries(props).forEach(([prop, value]) => {\n            properties[prop] = value;\n        });\n        propertyMap.set(ctx, properties);\n        return properties;\n    }\n}\nconst coalescingContextPropertiesMap = createPropertiesWeakMap((ctx) => ({\n    numCoalescingSubscribers: 0,\n}));\n/**\n * @describe createCoalesceManager\n *\n * returns a\n * Maintains a weak map of component references ans flags\n * them if the coalescing process is already started for them.\n *\n * Used in render aware internally.\n */\nfunction createCoalesceManager() {\n    return {\n        remove: removeWork,\n        add: addWork,\n        isCoalescing,\n    };\n    // Increments the number of subscriptions in a scope e.g. a class instance\n    function removeWork(scope) {\n        const numCoalescingSubscribers = coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers -\n            1;\n        coalescingContextPropertiesMap.setProps(scope, {\n            numCoalescingSubscribers: numCoalescingSubscribers >= 0 ? numCoalescingSubscribers : 0,\n        });\n    }\n    // Decrements the number of subscriptions in a scope e.g. a class instance\n    function addWork(scope) {\n        const numCoalescingSubscribers = coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers +\n            1;\n        coalescingContextPropertiesMap.setProps(scope, {\n            numCoalescingSubscribers,\n        });\n    }\n    // Checks if anybody else is already coalescing atm\n    function isCoalescing(scope) {\n        return (coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers >\n            0);\n    }\n}\n\n/**\n * @description\n * Limits the number of synchronous emitted a value from the source Observable to\n * one emitted value per\n *   durationSelector e.g. [`AnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame), then repeats\n * this process for every tick of the browsers event loop.\n *\n * The coalesce operator is based on the [throttle](https://rxjs-dev.firebaseapp.com/api/operators/throttle) operator.\n * In addition to that is provides emitted values for the trailing end only, as well as maintaining a context to scope\n *   coalescing.\n *\n * @param {function(value: T): Observable} durationSelector - A function\n * that receives a value from the source Observable, for computing the silencing\n * duration for each source value, returned as an Observable or a Promise.\n * It defaults to `requestAnimationFrame` as durationSelector.\n * @param scope\n * Defaults to `{ leading: false, trailing: true }`. The default scoping is per subscriber.\n * @return {Observable<T>} An Observable that performs the coalesce operation to\n * limit the rate of emissions from the source.\n *\n * @usageNotes\n * Emit clicks at a rate of at most one click per second\n * ```typescript\n * import { interval, fromEvent } from 'rxjs';\n * import { coalesceWith } from '@rx-angular/cdk/coalescing';\n *\n * const setTimeoutDurationSelector = interval(500);\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(coalesceWith(setTimeoutDurationSelector));\n * result.subscribe(x => console.log(x));\n * ```\n */\nfunction coalesceWith(durationSelector, scope) {\n    const _scope = scope || {};\n    return (source) => {\n        return new Observable((observer) => {\n            const rootSubscription = new Subscription();\n            rootSubscription.add(source.subscribe(createInnerObserver(observer, rootSubscription)));\n            return rootSubscription;\n        });\n        function createInnerObserver(outerObserver, rootSubscription) {\n            let actionSubscription;\n            let latestValue;\n            const tryEmitLatestValue = () => {\n                if (actionSubscription) {\n                    // We only decrement the number if it is greater than 0 (isCoalescing)\n                    coalescingManager.remove(_scope);\n                    if (!coalescingManager.isCoalescing(_scope)) {\n                        outerObserver.next(latestValue);\n                    }\n                }\n            };\n            return {\n                complete: () => {\n                    tryEmitLatestValue();\n                    outerObserver.complete();\n                },\n                error: (error) => outerObserver.error(error),\n                next: (value) => {\n                    latestValue = value;\n                    if (!actionSubscription) {\n                        coalescingManager.add(_scope);\n                        actionSubscription = durationSelector.subscribe({\n                            error: (error) => outerObserver.error(error),\n                            next: () => {\n                                tryEmitLatestValue();\n                                actionSubscription?.unsubscribe();\n                                actionSubscription = undefined;\n                            },\n                            complete: () => {\n                                tryEmitLatestValue();\n                                actionSubscription = undefined;\n                            },\n                        });\n                        rootSubscription.add(new Subscription(() => {\n                            tryEmitLatestValue();\n                            actionSubscription?.unsubscribe();\n                            actionSubscription = undefined;\n                        }));\n                    }\n                },\n            };\n        }\n    };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { coalesceWith, coalescingManager };\n\n", "import { ɵglobal } from '@angular/core';\nimport { Observable, from, combineLatest } from 'rxjs';\nimport { mapTo, concatMap, filter, distinctUntilChanged, map, shareReplay } from 'rxjs/operators';\nimport { coalesceWith } from '@rx-angular/cdk/coalescing';\n\nfunction getZoneUnPatchedApi(targetOrName, name) {\n    // If the user has provided the API name as the first argument, for instance:\n    // `const addEventListener = getZoneUnPatchedApi('addEventListener');`\n    // Then we just swap arguments and make `global` or `window` as the default target.\n    if (typeof targetOrName === 'string') {\n        name = targetOrName;\n        targetOrName = ɵglobal;\n    }\n    return targetOrName['__zone_symbol__' + String(name)] || targetOrName[name];\n}\n\n/**\n * Creates an Observable that emits after a setTimeout.\n * The timeout it unpatched to not avoid zone pollution\n * @param setTimeoutFn\n */\nfunction timeout(delay = 0) {\n    return new Observable((subscriber) => {\n        const asyncID = getZoneUnPatchedApi('setTimeout')(() => subscriber.next(0), delay);\n        return () => {\n            getZoneUnPatchedApi('clearTimeout')(asyncID);\n        };\n    });\n}\n/**\n *\n */\nfunction timeoutSwitchMapWith() {\n    return (o$) => o$.pipe(concatMap((v) => timeout().pipe(mapTo(v))));\n}\n\nconst resolvedPromise = getZoneUnPatchedApi('Promise').resolve();\nconst resolvedPromise$ = from(resolvedPromise);\n/**\n * @internal\n *\n * Used for typing\n */\nfunction getEntriesToObjectReducerFn(keys) {\n    return (accumulator, currentValue, currentIndex) => {\n        return {\n            ...accumulator,\n            [keys[currentIndex]]: currentValue,\n        };\n    };\n}\n/**\n * This Observable creation function helps to accumulate an object of key & Observable of values to\n * an Observable of objects of key & value.\n * This comes in handy if you quickly want to create subsets as objects/state-slices of different Observables.\n *\n * The resulting Observable filters out undefined values forwards only distinct values and shared the aggregated output.\n *\n * @example\n *\n * Default usage:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * });\n *\n * Usage with custom duration selector:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * }, timer(0, 20));\n *\n * @param obj - An object of key & Observable values pairs\n * @param durationSelector - An Observable determining the duration for the internal coalescing method\n */\nfunction accumulateObservables(\n// @TODO type static or Observable to enable mixing of imperative and reatctive values\nobj, durationSelector = resolvedPromise$) {\n    const keys = Object.keys(obj);\n    // @TODO better typing to enable static values => coerceObservable(obj[key])\n    const observables = keys.map((key) => obj[key].pipe(\n    // we avoid using the nullish operator later ;)\n    filter((v) => v !== undefined), \n    // state \"changes\" differ from each other, this operator ensures distinct values\n    distinctUntilChanged()));\n    return combineLatest(observables).pipe(\n    // As combineLatest will emit multiple times for a change in multiple properties we coalesce those emissions\n    // together\n    coalesceWith(durationSelector), \n    // mapping array of values to object\n    map((values) => values.reduce(getEntriesToObjectReducerFn(keys), {})), \n    // by using shareReplay we share the last composition work done to create the accumulated object\n    shareReplay({ refCount: true, bufferSize: 1 }));\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { accumulateObservables, getZoneUnPatchedApi, timeoutSwitchMapWith };\n\n", "import * as i0 from '@angular/core';\nimport { NgZone, InjectionToken, Injectable, Optional, Inject } from '@angular/core';\nimport { Observable, throwError, BehaviorSubject, fromEvent, ReplaySubject } from 'rxjs';\nimport { filter, mapTo, switchMap, tap, catchError, map, take, shareReplay, takeUntil, switchAll, startWith, share } from 'rxjs/operators';\nimport { forceFrameRate, scheduleCallback, cancelCallback } from '@rx-angular/cdk/internals/scheduler';\nimport { coalescingManager, coalesceWith } from '@rx-angular/cdk/coalescing';\nimport { getZoneUnPatchedApi } from '@rx-angular/cdk/internals/core';\nimport { coerceAllFactory } from '@rx-angular/cdk/coercing';\n\n// set default to 60fps\nforceFrameRate(60);\nconst immediateStrategy = {\n  name: 'immediate',\n  work: cdRef => cdRef.detectChanges(),\n  behavior: ({\n    work,\n    scope,\n    ngZone\n  }) => {\n    return o$ => o$.pipe(scheduleOnQueue(work, {\n      ngZone,\n      priority: 1 /* PriorityLevel.ImmediatePriority */,\n      scope\n    }));\n  }\n};\nconst userBlockingStrategy = {\n  name: 'userBlocking',\n  work: cdRef => cdRef.detectChanges(),\n  behavior: ({\n    work,\n    scope,\n    ngZone\n  }) => {\n    return o$ => o$.pipe(scheduleOnQueue(work, {\n      ngZone,\n      priority: 2 /* PriorityLevel.UserBlockingPriority */,\n      scope\n    }));\n  }\n};\nconst normalStrategy = {\n  name: 'normal',\n  work: cdRef => cdRef.detectChanges(),\n  behavior: ({\n    work,\n    scope,\n    ngZone\n  }) => {\n    return o$ => o$.pipe(scheduleOnQueue(work, {\n      ngZone,\n      priority: 3 /* PriorityLevel.NormalPriority */,\n      scope\n    }));\n  }\n};\nconst lowStrategy = {\n  name: 'low',\n  work: cdRef => cdRef.detectChanges(),\n  behavior: ({\n    work,\n    scope,\n    ngZone\n  }) => {\n    return o$ => o$.pipe(scheduleOnQueue(work, {\n      ngZone,\n      priority: 4 /* PriorityLevel.LowPriority */,\n      scope\n    }));\n  }\n};\nconst idleStrategy = {\n  name: 'idle',\n  work: cdRef => cdRef.detectChanges(),\n  behavior: ({\n    work,\n    scope,\n    ngZone\n  }) => {\n    return o$ => o$.pipe(scheduleOnQueue(work, {\n      ngZone,\n      priority: 5 /* PriorityLevel.IdlePriority */,\n      scope\n    }));\n  }\n};\nfunction scheduleOnQueue(work, options) {\n  const scope = options.scope || {};\n  return o$ => o$.pipe(filter(() => !coalescingManager.isCoalescing(scope)), switchMap(v => new Observable(subscriber => {\n    coalescingManager.add(scope);\n    const task = scheduleCallback(options.priority, () => {\n      work();\n      coalescingManager.remove(scope);\n      subscriber.next(v);\n    }, {\n      delay: options.delay,\n      ngZone: options.ngZone\n    });\n    return () => {\n      coalescingManager.remove(scope);\n      cancelCallback(task);\n    };\n  }).pipe(mapTo(v))));\n}\nconst RX_CONCURRENT_STRATEGIES = {\n  immediate: immediateStrategy,\n  userBlocking: userBlockingStrategy,\n  normal: normalStrategy,\n  low: lowStrategy,\n  idle: idleStrategy\n};\nconst animationFrameTick = () => new Observable(subscriber => {\n  // use the unpatched API no avoid zone interference\n  const id = getZoneUnPatchedApi('requestAnimationFrame')(() => {\n    subscriber.next(0);\n    subscriber.complete();\n  });\n  return () => {\n    // use the unpatched API no avoid zone interference\n    getZoneUnPatchedApi('cancelAnimationFrame')(id);\n  };\n});\nconst localCredentials = {\n  name: 'local',\n  work: (cdRef, _, notification) => {\n    cdRef.detectChanges();\n  },\n  behavior: ({\n    work,\n    scope,\n    ngZone\n  }) => o$ => o$.pipe(coalesceWith(animationFrameTick(), scope), tap(() => ngZone ? ngZone.run(() => work()) : work()))\n};\nconst noopCredentials = {\n  name: 'noop',\n  work: () => void 0,\n  behavior: () => o$ => o$\n};\nconst nativeCredentials = {\n  name: 'native',\n  work: cdRef => cdRef.markForCheck(),\n  behavior: ({\n    work,\n    ngZone\n  }) => o$ => o$.pipe(tap(() => ngZone && !NgZone.isInAngularZone() ? ngZone.run(() => work()) : work()))\n};\nconst RX_NATIVE_STRATEGIES = {\n  native: nativeCredentials,\n  noop: noopCredentials,\n  local: localCredentials\n};\nconst RX_RENDER_STRATEGIES_CONFIG = new InjectionToken('rxa-render-strategies-config');\nconst RX_RENDER_STRATEGIES_DEFAULTS = {\n  primaryStrategy: 'normal',\n  customStrategies: {\n    ...RX_NATIVE_STRATEGIES,\n    ...RX_CONCURRENT_STRATEGIES\n  },\n  patchZone: true,\n  parent: true\n};\nfunction mergeDefaultConfig(cfg) {\n  const custom = cfg ? cfg : {\n    customStrategies: {}\n  };\n  return {\n    ...RX_RENDER_STRATEGIES_DEFAULTS,\n    ...custom,\n    customStrategies: {\n      ...custom.customStrategies,\n      ...RX_RENDER_STRATEGIES_DEFAULTS.customStrategies\n    }\n  };\n}\n\n/**\n * @internal\n *\n * @param value\n * @param strategy\n * @param workFactory\n * @param options\n */\nfunction onStrategy(value, strategy, workFactory, options = {}) {\n  return new Observable(subscriber => {\n    subscriber.next(value);\n  }).pipe(strategy.behavior({\n    work: () => workFactory(value, strategy.work, options),\n    scope: options.scope || {},\n    ngZone: options.ngZone\n  }), catchError(error => throwError(() => [error, value])), map(() => value), take(1));\n}\n\n/**\n * @description\n * RxStrategyProvider is a wrapper service that you can use to consume strategies and schedule your code execution.\n *\n * @example\n * Component({\n *   selector: 'app-service-communicator',\n *   template: ``\n * });\n * export class ServiceCommunicationComponent {\n *   private currentUserSettings;\n *\n *   constructor(\n *     private strategyProvider: RxStrategyProvider,\n *     private userService: UserService,\n *     private backgroundSync: BackgroundSyncService\n *   ) {\n *     this.userService.fetchCurrentUserSettings\n *       .pipe(\n *         tap(settings => (this.currentUserSettings = settings)),\n *         this.strategyProvider.scheduleWith(\n *           settings => this.backgroundSync.openConnection(settings),\n *           { strategy: 'idle' }\n *         )\n *       )\n *       .subscribe();\n *   }\n * }\n *\n * @docsCategory RxStrategyProvider\n * @docsPage RxStrategyProvider\n */\nclass RxStrategyProvider {\n  _strategies$ = new BehaviorSubject(undefined);\n  _primaryStrategy$ = new BehaviorSubject(undefined);\n  _cfg;\n  /**\n   * @description\n   * Returns current `RxAngularConfig` used in the service.\n   * Config includes:\n   * - strategy that currently in use - `primaryStrategy`\n   * - array of custom user defined strategies - `customStrategies`\n   * - setting that is responsible for running in our outside of the zone.js - `patchZone`\n   */\n  get config() {\n    return this._cfg;\n  }\n  /**\n   * @description\n   * Returns object that contains key-value pairs of strategy names and their credentials (settings) that are available in the service.\n   */\n  get strategies() {\n    return this._strategies$.getValue();\n  }\n  /**\n   * @description\n   * Returns an array of strategy names available in the service.\n   */\n  get strategyNames() {\n    return Object.values(this.strategies).map(s => s.name);\n  }\n  /**\n   * @description\n   * Returns current strategy of the service.\n   */\n  get primaryStrategy() {\n    return this._primaryStrategy$.getValue().name;\n  }\n  /**\n   * @description\n   * Set's the strategy that will be used by the service.\n   */\n  set primaryStrategy(strategyName) {\n    this._primaryStrategy$.next(this.strategies[strategyName]);\n  }\n  /**\n   * @description\n   * Current strategy of the service as an observable.\n   */\n  primaryStrategy$ = this._primaryStrategy$.asObservable();\n  /**\n   * @description\n   * Returns observable of an object that contains key-value pairs of strategy names and their credentials (settings) that are available in the service.\n   */\n  strategies$ = this._strategies$.asObservable();\n  /**\n   * @description\n   * Returns an observable of an array of strategy names available in the service.\n   */\n  strategyNames$ = this.strategies$.pipe(map(strategies => Object.values(strategies).map(s => s.name)), shareReplay({\n    bufferSize: 1,\n    refCount: true\n  }));\n  /**\n   * @internal\n   */\n  constructor(cfg) {\n    this._cfg = mergeDefaultConfig(cfg);\n    this._strategies$.next(this._cfg.customStrategies);\n    this.primaryStrategy = this.config.primaryStrategy;\n  }\n  /**\n   * @description\n   * Allows to schedule a work inside rxjs `pipe`. Accepts the work and configuration options object.\n   * - work is any function that should be executed\n   * - (optional) options includes strategy, patchZone and scope\n   *\n   * Scope is by default a subscription but you can also pass `this` and then the scope will be current component.\n   * Scope setup is useful if your work is some of the methods of `ChangeDetectorRef`. Only one change detection will be triggered if you have multiple schedules of change detection methods and scope is set to `this`.\n   *\n   * @example\n   * myObservable$.pipe(\n   *    this.strategyProvider.scheduleWith(() => myWork(), {strategy: 'idle', patchZone: false})\n   * ).subscribe();\n   *\n   * @return MonoTypeOperatorFunction<R>\n   */\n  scheduleWith(work, options) {\n    const strategy = this.strategies[options?.strategy || this.primaryStrategy];\n    const scope = options?.scope || {};\n    const _work = getWork(work, options?.patchZone);\n    const ngZone = options?.patchZone || undefined;\n    return o$ => o$.pipe(switchMap(v => onStrategy(v, strategy, _v => {\n      _work(_v);\n    }, {\n      scope,\n      ngZone\n    })));\n  }\n  /**\n   * @description\n   * Allows to schedule a work as an observable. Accepts the work and configuration options object.\n   * - work is any function that should be executed\n   * - (optional) options includes strategy, patchZone and scope\n   *\n   * Scope is by default a subscription but you can also pass `this` and then the scope will be current component.\n   * Scope setup is especially useful if you provide work that will trigger a change detection.\n   *\n   * @example\n   * this.strategyProvider.schedule(() => myWork(), {strategy: 'idle', patchZone: false}).subscribe();\n   *\n   * @return Observable<R>\n   */\n  schedule(work, options) {\n    const strategy = this.strategies[options?.strategy || this.primaryStrategy];\n    const scope = options?.scope || {};\n    const _work = getWork(work, options?.patchZone);\n    const ngZone = options?.patchZone || undefined;\n    let returnVal;\n    return onStrategy(null, strategy, () => {\n      returnVal = _work();\n    }, {\n      scope,\n      ngZone\n    }).pipe(map(() => returnVal));\n  }\n  /**\n   * @description\n   * Allows to schedule a change detection cycle. Accepts the ChangeDetectorRef and configuration options object.\n   * Options include:\n   * - afterCD which is the work that should be executed after change detection cycle.\n   * - abortCtrl is an AbortController that you can use to cancel the scheduled cycle.\n   *\n   * @example\n   * this.strategyProvider.scheduleCd(this.changeDetectorRef, {afterCD: myWork()});\n   *\n   * @return AbortController\n   */\n  scheduleCD(cdRef, options) {\n    const strategy = this.strategies[options?.strategy || this.primaryStrategy];\n    const scope = options?.scope || cdRef;\n    const abC = options?.abortCtrl || new AbortController();\n    const ngZone = options?.patchZone || undefined;\n    const work = getWork(() => {\n      strategy.work(cdRef, scope);\n      if (options?.afterCD) {\n        options.afterCD();\n      }\n    }, options.patchZone);\n    onStrategy(null, strategy, () => {\n      work();\n    }, {\n      scope,\n      ngZone\n    }).pipe(takeUntil(fromEvent(abC.signal, 'abort'))).subscribe();\n    return abC;\n  }\n  /** @nocollapse */\n  static ɵfac = function RxStrategyProvider_Factory(t) {\n    return new (t || RxStrategyProvider)(i0.ɵɵinject(RX_RENDER_STRATEGIES_CONFIG, 8));\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RxStrategyProvider,\n    factory: RxStrategyProvider.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RxStrategyProvider, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [RX_RENDER_STRATEGIES_CONFIG]\n    }]\n  }], null);\n})();\nfunction getWork(work, patchZone) {\n  let _work = work;\n  if (patchZone) {\n    _work = args => patchZone.run(() => work(args));\n  }\n  return _work;\n}\n\n/**\n * @internal\n *\n * A factory function returning an object to handle the process of turning strategy names into `RxStrategyCredentials`\n * You can next a strategy name as Observable or string and get an Observable of `RxStrategyCredentials`\n *\n * @param defaultStrategyName\n * @param strategies\n */\nfunction strategyHandling(defaultStrategyName, strategies) {\n  const hotFlattened = coerceAllFactory(() => new ReplaySubject(1), switchAll());\n  return {\n    strategy$: hotFlattened.values$.pipe(startWith(defaultStrategyName), nameToStrategyCredentials(strategies, defaultStrategyName), share()),\n    next(name) {\n      hotFlattened.next(name);\n    }\n  };\n}\n/**\n * @internal\n */\nfunction nameToStrategyCredentials(strategies, defaultStrategyName) {\n  return o$ => o$.pipe(map(name => name && Object.keys(strategies).includes(name) ? strategies[name] : strategies[defaultStrategyName]));\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { RX_CONCURRENT_STRATEGIES, RX_NATIVE_STRATEGIES, RX_RENDER_STRATEGIES_CONFIG, RxStrategyProvider, onStrategy, strategyHandling };\n", "import { onStrategy, strategyHandling } from '@rx-angular/cdk/render-strategies';\nimport { of, BehaviorSubject, concat, EMPTY, merge, combineLatest, ReplaySubject } from 'rxjs';\nimport { ignoreElements, switchMap, map, withLatestFrom, catchError, tap, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * @internal\n * creates an embeddedViewRef\n *\n * @param viewContainerRef\n * @param templateRef\n * @param context\n * @param index\n * @return EmbeddedViewRef<C>\n */\nfunction createEmbeddedView(viewContainerRef, templateRef, context, index = 0) {\n    const view = viewContainerRef.createEmbeddedView(templateRef, context, index);\n    view.detectChanges();\n    return view;\n}\n/**\n * @internal\n *\n * A factory function returning an object to handle `TemplateRef`'s.\n * You can add and get a `TemplateRef`.\n *\n */\nfunction templateHandling(viewContainerRef) {\n    const templateCache = new Map();\n    const get$ = (name) => {\n        return templateCache.get(name) || of(undefined);\n    };\n    const get = (name) => {\n        let ref;\n        const templatRef$ = get$(name);\n        if (templatRef$) {\n            const sub = templatRef$.subscribe((r) => (ref = r));\n            sub.unsubscribe();\n        }\n        return ref;\n    };\n    return {\n        add(name, templateRef) {\n            assertTemplate(name, templateRef);\n            if (!templateCache.has(name)) {\n                templateCache.set(name, new BehaviorSubject(templateRef));\n            }\n            else {\n                templateCache.get(name).next(templateRef);\n            }\n        },\n        get$,\n        get,\n        createEmbeddedView: (name, context) => createEmbeddedView(viewContainerRef, get(name), context),\n    };\n    //\n    function assertTemplate(property, templateRef) {\n        const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);\n        if (!isTemplateRefOrNull) {\n            throw new Error(`${property} must be a TemplateRef, but received ${typeof templateRef}`);\n        }\n        return isTemplateRefOrNull;\n    }\n}\n/**\n * @internal\n *\n * A side effect operator similar to `tap` but with a static internal logic.\n * It calls detect changes on the 'VirtualParent' and the injectingViewCdRef.\n *\n * @param injectingViewCdRef\n * @param strategy\n * @param notifyNeeded\n * @param ngZone\n */\nfunction notifyAllParentsIfNeeded(injectingViewCdRef, strategy, notifyNeeded, ngZone) {\n    return (o$) => o$.pipe(switchMap((v) => {\n        const notifyParent = notifyNeeded();\n        if (!notifyParent) {\n            return of(v);\n        }\n        return concat(of(v), onStrategy(injectingViewCdRef, strategy, (_v, work, options) => {\n            /*console.log(\n             'notifyAllParentsIfNeeded injectingView',\n             (injectingViewCdRef as any).context\n             );*/\n            work(injectingViewCdRef, options.scope);\n        }, {\n            scope: injectingViewCdRef.context || injectingViewCdRef,\n            ngZone,\n        }).pipe(ignoreElements()));\n    }));\n}\n\nvar RxBaseTemplateNames;\n(function (RxBaseTemplateNames) {\n    RxBaseTemplateNames[\"error\"] = \"errorTpl\";\n    RxBaseTemplateNames[\"complete\"] = \"completeTpl\";\n    RxBaseTemplateNames[\"suspense\"] = \"suspenseTpl\";\n})(RxBaseTemplateNames || (RxBaseTemplateNames = {}));\n\n/** @internal **/\nfunction isRxRenderError(e) {\n    return (e != null && Array.isArray(e) && e.length === 2 && e[0] instanceof Error);\n}\n/** @internal **/\nfunction createErrorHandler(_handler) {\n    const _handleError = _handler\n        ? (e) => _handler.handleError(e)\n        : console.error;\n    return {\n        handleError: (error) => {\n            if (isRxRenderError(error)) {\n                _handleError(error[0]);\n                console.error('additionalErrorContext', error[1]);\n            }\n            else {\n                _handleError(error);\n            }\n        },\n    };\n}\n/** @internal **/\nfunction toRenderError(e, context) {\n    return [e, context];\n}\n\n/**\n * @internal\n *\n * A factory function that returns a map of projections to turn a notification of a Observable (next, error, complete)\n *\n * @param customNextContext - projection function to provide custom properties as well as override existing\n */\nfunction notificationKindToViewContext(customNextContext) {\n    // @TODO rethink overrides\n    return {\n        suspense: (notification) => {\n            const $implicit = notification.value;\n            return {\n                $implicit,\n                suspense: true,\n                error: false,\n                complete: false,\n                ...customNextContext($implicit),\n            };\n        },\n        next: (notification) => {\n            const $implicit = notification.value;\n            return {\n                $implicit,\n                suspense: false,\n                error: false,\n                complete: false,\n                ...customNextContext($implicit),\n            };\n        },\n        error: (notification) => {\n            const $implicit = notification.value;\n            return {\n                $implicit,\n                complete: false,\n                error: notification.error || true,\n                suspense: false,\n                ...customNextContext($implicit),\n            };\n        },\n        complete: (notification) => {\n            const $implicit = notification.value;\n            return {\n                $implicit,\n                error: false,\n                complete: true,\n                suspense: false,\n                ...customNextContext($implicit),\n            };\n        },\n    };\n}\nfunction createTemplateManager(config) {\n    const { renderSettings, notificationToTemplateName, templateSettings } = config;\n    const { defaultStrategyName, strategies, cdRef: injectingViewCdRef, patchZone, parent, } = renderSettings;\n    const errorHandler = createErrorHandler(renderSettings.errorHandler);\n    const ngZone = patchZone ? patchZone : undefined;\n    let activeTemplate;\n    const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);\n    const templates = templateHandling(templateSettings.viewContainerRef);\n    const viewContainerRef = templateSettings.viewContainerRef;\n    const triggerHandling = config.templateTrigger$ || EMPTY;\n    const getContext = notificationKindToViewContext(templateSettings.customContext || (() => ({})));\n    return {\n        addTemplateRef: (name, templateRef) => {\n            templates.add(name, templateRef);\n        },\n        nextStrategy: strategyHandling$.next,\n        render(values$) {\n            let trg;\n            let notification = {\n                value: undefined,\n                complete: false,\n                error: false,\n                kind: \"suspense\" /* RxNotificationKind.Suspense */,\n                hasValue: false,\n            };\n            return merge(values$.pipe(tap((n) => (notification = n))), triggerHandling.pipe(tap((trigger) => (trg = trigger)))).pipe(switchMap(() => {\n                const contextKind = trg || notification.kind;\n                trg = undefined;\n                const value = notification.value;\n                const templateName = notificationToTemplateName[contextKind](value, templates);\n                return templates.get$(templateName).pipe(map((template) => ({\n                    template,\n                    templateName,\n                    notification,\n                    contextKind,\n                })));\n            }), withLatestFrom(strategyHandling$.strategy$), \n            // Cancel old renders\n            switchMap(([{ template, templateName, notification, contextKind }, strategy,]) => {\n                const isNewTemplate = activeTemplate !== template || !template;\n                const notifyParent = isNewTemplate && parent;\n                return onStrategy(notification.value, strategy, (v, work, options) => {\n                    const context = getContext[contextKind](notification);\n                    if (isNewTemplate) {\n                        // template has changed (undefined => next; suspense => next; ...)\n                        // handle remove & insert\n                        // remove current view if there is any\n                        if (viewContainerRef.length > 0) {\n                            // patch removal if needed\n                            viewContainerRef.clear();\n                        }\n                        // create new view if any\n                        if (template) {\n                            // createEmbeddedView is already patched, no need for workFactory\n                            templates.createEmbeddedView(templateName, context);\n                        }\n                    }\n                    else if (template) {\n                        // template didn't change, update it\n                        // handle update\n                        const view = viewContainerRef.get(0);\n                        Object.keys(context).forEach((k) => {\n                            view.context[k] = context[k];\n                        });\n                        // update view context, patch if needed\n                        work(view, options.scope, notification);\n                    }\n                    activeTemplate = template;\n                }, { ngZone }\n                // we don't need to specify any scope here. The template manager is the only one\n                // who will call `viewRef#detectChanges` on any of the templates it manages.\n                // whenever a new value comes in, any pre-scheduled work of this taskManager will\n                // be nooped before a new work will be scheduled. This happens because of the implementation\n                // of `StrategyCredential#behavior`\n                ).pipe(notifyAllParentsIfNeeded(injectingViewCdRef, strategy, () => notifyParent, ngZone), catchError((e) => {\n                    errorHandler.handleError(e);\n                    return of(e);\n                }));\n            }));\n        },\n    };\n}\n\n/**\n * @internal\n *\n * Factory that returns a `ListTemplateManager` for the passed params.\n *\n * @param templateSettings\n */\nfunction getTemplateHandler(templateSettings) {\n    const { viewContainerRef, initialTemplateRef, createViewContext, updateViewContext, } = templateSettings;\n    return {\n        updateUnchangedContext,\n        insertView,\n        moveView,\n        removeView,\n        getListChanges,\n        updateView,\n    };\n    // =====\n    function updateUnchangedContext(item, index, count) {\n        const view = viewContainerRef.get(index);\n        updateViewContext(item, view, {\n            count,\n            index,\n        });\n        view.detectChanges();\n    }\n    function moveView(oldIndex, item, index, count) {\n        const oldView = viewContainerRef.get(oldIndex);\n        const view = viewContainerRef.move(oldView, index);\n        updateViewContext(item, view, {\n            count,\n            index,\n        });\n        view.detectChanges();\n    }\n    function updateView(item, index, count) {\n        const view = viewContainerRef.get(index);\n        updateViewContext(item, view, {\n            count,\n            index,\n        });\n        view.detectChanges();\n    }\n    function removeView(index) {\n        return viewContainerRef.remove(index);\n    }\n    function insertView(item, index, count) {\n        createEmbeddedView(viewContainerRef, initialTemplateRef, createViewContext(item, {\n            count,\n            index,\n        }), index);\n    }\n}\n/**\n * @internal\n *\n * @param changes\n * @param items\n */\nfunction getListChanges(changes, items) {\n    const changedIdxs = new Set();\n    const changesArr = [];\n    let notifyParent = false;\n    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n        const item = record.item;\n        if (record.previousIndex == null) {\n            // insert\n            changesArr.push(getInsertChange(item, currentIndex === null ? undefined : currentIndex));\n            changedIdxs.add(item);\n            notifyParent = true;\n        }\n        else if (currentIndex == null) {\n            // remove\n            changesArr.push(getRemoveChange(item, adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex));\n            notifyParent = true;\n        }\n        else if (adjustedPreviousIndex !== null) {\n            // move\n            changesArr.push(getMoveChange(item, currentIndex, adjustedPreviousIndex));\n            changedIdxs.add(item);\n            notifyParent = true;\n        }\n    });\n    changes.forEachIdentityChange((record) => {\n        const item = record.item;\n        if (!changedIdxs.has(item)) {\n            changesArr.push(getUpdateChange(item, record.currentIndex));\n            changedIdxs.add(item);\n        }\n    });\n    items.forEach((item, index) => {\n        if (!changedIdxs.has(item)) {\n            changesArr.push(getUnchangedChange(item, index));\n        }\n    });\n    return [changesArr, notifyParent];\n    // ==========\n    function getMoveChange(item, currentIndex, adjustedPreviousIndex) {\n        return [\n            2 /* RxListTemplateChangeType.move */,\n            [item, currentIndex, adjustedPreviousIndex],\n        ];\n    }\n    function getUpdateChange(item, currentIndex) {\n        return [3 /* RxListTemplateChangeType.update */, [item, currentIndex]];\n    }\n    function getUnchangedChange(item, index) {\n        return [4 /* RxListTemplateChangeType.context */, [item, index]];\n    }\n    function getInsertChange(item, currentIndex) {\n        return [\n            0 /* RxListTemplateChangeType.insert */,\n            [item, currentIndex === null ? undefined : currentIndex],\n        ];\n    }\n    function getRemoveChange(item, adjustedPreviousIndex) {\n        return [\n            1 /* RxListTemplateChangeType.remove */,\n            [\n                item,\n                adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex,\n            ],\n        ];\n    }\n}\n\nfunction createListTemplateManager(config) {\n    const { templateSettings, renderSettings, trackBy, iterableDiffers } = config;\n    const { defaultStrategyName, strategies, cdRef: injectingViewCdRef, patchZone, parent, } = renderSettings;\n    const errorHandler = createErrorHandler(renderSettings.errorHandler);\n    const ngZone = patchZone ? patchZone : undefined;\n    const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);\n    let _differ;\n    function getDiffer(values) {\n        if (_differ) {\n            return _differ;\n        }\n        return values\n            ? (_differ = iterableDiffers.find(values).create(trackBy))\n            : null;\n    }\n    //               type,  context\n    /* TODO (regarding createView): this is currently not in use. for the list-manager this would mean to provide\n     functions for not only create. developers than should have to provide create, move, remove,... the whole thing.\n     i don't know if this is the right decision for a first RC */\n    const listViewHandler = getTemplateHandler({\n        ...templateSettings,\n        initialTemplateRef: templateSettings.templateRef,\n    });\n    const viewContainerRef = templateSettings.viewContainerRef;\n    let notifyParent = false;\n    let changesArr;\n    let partiallyFinished = false;\n    return {\n        nextStrategy(nextConfig) {\n            strategyHandling$.next(nextConfig);\n        },\n        render(values$) {\n            return values$.pipe(render());\n        },\n    };\n    function handleError() {\n        return (o$) => o$.pipe(catchError((err) => {\n            partiallyFinished = false;\n            errorHandler.handleError(err);\n            return of(null);\n        }));\n    }\n    function render() {\n        return (o$) => combineLatest([\n            o$,\n            strategyHandling$.strategy$.pipe(distinctUntilChanged()),\n        ]).pipe(map(([iterable, strategy]) => {\n            const differ = getDiffer(iterable);\n            let changes;\n            if (differ) {\n                if (partiallyFinished) {\n                    const currentIterable = [];\n                    for (let i = 0, ilen = viewContainerRef.length; i < ilen; i++) {\n                        const viewRef = viewContainerRef.get(i);\n                        currentIterable[i] = viewRef.context.$implicit;\n                    }\n                    differ.diff(currentIterable);\n                }\n                changes = differ.diff(iterable);\n            }\n            return {\n                changes,\n                iterable,\n                strategy,\n            };\n        }), \n        // Cancel old renders\n        switchMap(({ changes, iterable, strategy }) => {\n            if (!changes) {\n                return of([]);\n            }\n            const values = iterable || [];\n            // TODO: we might want to treat other iterables in a more performant way than Array.from()\n            const items = Array.isArray(values) ? values : Array.from(iterable);\n            const listChanges = listViewHandler.getListChanges(changes, items);\n            changesArr = listChanges[0];\n            const insertedOrRemoved = listChanges[1];\n            const applyChanges$ = getObservablesFromChangesArray(changesArr, strategy, items.length);\n            partiallyFinished = true;\n            notifyParent = insertedOrRemoved && parent;\n            return combineLatest(applyChanges$.length > 0 ? applyChanges$ : [of(null)]).pipe(tap(() => (partiallyFinished = false)), notifyAllParentsIfNeeded(injectingViewCdRef, strategy, () => notifyParent, ngZone), handleError(), map(() => iterable));\n        }), handleError());\n    }\n    /**\n     * @internal\n     *\n     * returns an array of streams which process all of the view updates needed to reflect the latest diff to the\n     * viewContainer.\n     * I\n     *\n     * @param changes\n     * @param strategy\n     * @param count\n     */\n    function getObservablesFromChangesArray(changes, strategy, count) {\n        return changes.length > 0\n            ? changes.map((change) => {\n                const payload = change[1];\n                return onStrategy(change[0], strategy, (type) => {\n                    switch (type) {\n                        case 0 /* RxListTemplateChangeType.insert */:\n                            listViewHandler.insertView(payload[0], payload[1], count);\n                            break;\n                        case 2 /* RxListTemplateChangeType.move */:\n                            listViewHandler.moveView(payload[2], payload[0], payload[1], count);\n                            break;\n                        case 1 /* RxListTemplateChangeType.remove */:\n                            listViewHandler.removeView(payload[1]);\n                            break;\n                        case 3 /* RxListTemplateChangeType.update */:\n                            listViewHandler.updateView(payload[0], payload[1], count);\n                            break;\n                        case 4 /* RxListTemplateChangeType.context */:\n                            listViewHandler.updateUnchangedContext(payload[0], payload[1], count);\n                            break;\n                    }\n                }, { ngZone });\n            })\n            : [of(null)];\n    }\n}\n\nconst computeFirst = ({ count, index }) => index === 0;\nconst computeLast = ({ count, index }) => index === count - 1;\nconst computeEven = ({ count, index }) => index % 2 === 0;\nclass RxDefaultListViewContext {\n    _item = new ReplaySubject(1);\n    item$ = this._item.asObservable();\n    _$implicit;\n    _$complete;\n    _$error;\n    _$suspense;\n    _context$ = new BehaviorSubject({\n        index: -1,\n        count: -1,\n    });\n    set $implicit($implicit) {\n        this._$implicit = $implicit;\n        this._item.next($implicit);\n    }\n    get $implicit() {\n        return this._$implicit;\n    }\n    get $complete() {\n        return this._$complete;\n    }\n    get $error() {\n        return this._$error;\n    }\n    get $suspense() {\n        return this._$suspense;\n    }\n    get index() {\n        return this._context$.getValue().index;\n    }\n    get count() {\n        return this._context$.getValue().count;\n    }\n    get first() {\n        return computeFirst(this._context$.getValue());\n    }\n    get last() {\n        return computeLast(this._context$.getValue());\n    }\n    get even() {\n        return computeEven(this._context$.getValue());\n    }\n    get odd() {\n        return !this.even;\n    }\n    get index$() {\n        return this._context$.pipe(map((c) => c.index), distinctUntilChanged());\n    }\n    get count$() {\n        return this._context$.pipe(map((s) => s.count), distinctUntilChanged());\n    }\n    get first$() {\n        return this._context$.pipe(map(computeFirst), distinctUntilChanged());\n    }\n    get last$() {\n        return this._context$.pipe(map(computeLast), distinctUntilChanged());\n    }\n    get even$() {\n        return this._context$.pipe(map(computeEven), distinctUntilChanged());\n    }\n    get odd$() {\n        return this.even$.pipe(map((even) => !even));\n    }\n    constructor(item, customProps) {\n        this.$implicit = item;\n        if (customProps) {\n            this.updateContext(customProps);\n        }\n    }\n    updateContext(newProps) {\n        this._context$.next({\n            ...this._context$.getValue(),\n            ...newProps,\n        });\n    }\n    select = (props) => {\n        return this.item$.pipe(map((r) => props.reduce((acc, key) => acc?.[key], r)));\n    };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { RxBaseTemplateNames, RxDefaultListViewContext, createListTemplateManager, createTemplateManager, templateHandling };\n\n", "import * as i0 from '@angular/core';\nimport { IterableDiffers, inject, ChangeDetectorRef, NgZone, TemplateRef, ViewContainerRef, ErrorHandler, Directive, Input } from '@angular/core';\nimport { coerceObservableWith, coerceDistinctWith } from '@rx-angular/cdk/coercing';\nimport { RxStrategyProvider } from '@rx-angular/cdk/render-strategies';\nimport { RxDefaultListViewContext, createListTemplateManager } from '@rx-angular/cdk/template';\nimport { isObservable, ReplaySubject, Subscription } from 'rxjs';\nimport { switchAll, shareReplay } from 'rxjs/operators';\nclass RxForViewContext extends RxDefaultListViewContext {\n  rxForOf;\n  constructor(item, rxForOf, customProps) {\n    super(item, customProps);\n    this.rxForOf = rxForOf;\n  }\n}\n\n/**\n * @Directive RxFor\n *\n * @description\n *\n * The most common way to render lists in angular is by using the `*ngFor` structural directive. `*ngFor` is able\n * to take an arbitrary list of data and repeat a defined template per item of the list. However, it can\n * only do it synchronously.\n *\n * Compared to the `NgFor`, `RxFor` treats each child template as single renderable unit.\n * The change detection of the child templates get prioritized, scheduled and executed by\n * leveraging `RenderStrategies` under the hood.\n * This technique enables non-blocking rendering of lists and can be referred to as `concurrent mode`.\n *\n * Read more about this in the [strategies\n * section](https://www.rx-angular.io/docs/template/api/rx-for-directive#rxfor-with-concurrent-strategies).\n *\n * Furthermore, `RxFor` provides hooks to react to rendered items in form of a `renderCallback: Subject`.\n *\n * Together with the `RxRenderStrategies`, this makes the rendering behavior extremely versatile\n * and transparent for the developer.\n * Each instance of `RxFor` can be configured to render with different settings.\n *\n * Read more in the [official docs](https://www.rx-angular.io/docs/template/api/rx-for-directive)\n *\n * @docsCategory RxFor\n * @docsPage RxFor\n * @publicApi\n */\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nclass RxFor {\n  /** @internal */\n  iterableDiffers = inject(IterableDiffers);\n  /** @internal */\n  cdRef = inject(ChangeDetectorRef);\n  /** @internal */\n  ngZone = inject(NgZone);\n  /** @internal */\n  templateRef = inject(TemplateRef);\n  /** @internal */\n  viewContainerRef = inject(ViewContainerRef);\n  /** @internal */\n  strategyProvider = inject(RxStrategyProvider);\n  /** @internal */\n  errorHandler = inject(ErrorHandler);\n  /** @internal */\n  staticValue;\n  /** @internal */\n  renderStatic = false;\n  /**\n   * @description\n   * The iterable input\n   *\n   * @example\n   * <ng-container *rxFor=\"heroes$; let hero\">\n   *   <app-hero [hero]=\"hero\"></app-hero>\n   * </ng-container>\n   *\n   * @param { Observable<(U & NgIterable<T>) | undefined | null>\n   *       | (U & NgIterable<T>)\n   *       | null\n   *       | undefined } potentialObservable\n   */\n  set rxForOf(potentialObservable) {\n    if (!isObservable(potentialObservable)) {\n      this.staticValue = potentialObservable;\n      this.renderStatic = true;\n    } else {\n      this.staticValue = undefined;\n      this.renderStatic = false;\n      this.observables$.next(potentialObservable);\n    }\n  }\n  /**\n   * @internal\n   * A reference to the template that is created for each item in the iterable.\n   * @see [template reference variable](guide/template-reference-variables)\n   * (inspired by @angular/common `ng_for_of.ts`)\n   */\n  _template;\n  set rxForTemplate(value) {\n    this._template = value;\n  }\n  /**\n   * @description\n   *\n   * You can change the used `RenderStrategy` by using the `strategy` input of the `*rxFor`. It accepts\n   * an `Observable<RxStrategyNames>` or [`RxStrategyNames`](https://github.com/rx-angular/rx-angular/blob/b0630f69017cc1871d093e976006066d5f2005b9/libs/cdk/render-strategies/src/lib/model.ts#L52).\n   *\n   * The default value for strategy is\n   * [`normal`](https://www.rx-angular.io/docs/template/cdk/render-strategies/strategies/concurrent-strategies).\n   *\n   * Read more about this in the\n   * [official docs](https://www.rx-angular.io/docs/template/api/rx-for-directive#use-render-strategies-strategy).\n   *\n   * @example\n   *\n   * \\@Component({\n   *   selector: 'app-root',\n   *   template: `\n   *     <ng-container *rxFor=\"let hero of heroes$; strategy: strategy\">\n   *       <app-hero [hero]=\"hero\"></app-hero>\n   *     </ng-container>\n   *\n   *     <ng-container *rxFor=\"let hero of heroes$; strategy: strategy$\">\n   *       <app-hero [hero]=\"hero\"></app-hero>\n   *     </ng-container>\n   *   `\n   * })\n   * export class AppComponent {\n   *   strategy = 'low';\n   *   strategy$ = of('immediate');\n   * }\n   *\n   * @param {string | Observable<string> | undefined} strategyName\n   * @see {@link strategies}\n   */\n  set rxForStrategy(strategyName) {\n    this.strategyInput$.next(strategyName);\n  }\n  /**\n   * @description\n   *\n   * When local rendering strategies are used, we need to treat view and content queries in a\n   * special way.\n   * To make `*rxFor` in such situations, a certain mechanism is implemented to\n   * execute change detection on the parent (`parent`).\n   *\n   * This is required if your components state is dependent on its view or content children:\n   *\n   * - `@ViewChild`\n   * - `@ViewChildren`\n   * - `@ContentChild`\n   * - `@ContentChildren`\n   *\n   * Read more about this in the\n   * [official docs](https://www.rx-angular.io/docs/template/api/rx-for-directive#local-strategies-and-view-content-queries-parent).\n   *\n   * @example\n   * \\@Component({\n   *   selector: 'app-root',\n   *   template: `\n   *    <app-list-component>\n   *      <app-list-item\n   *        *rxFor=\"\n   *          let item of items$;\n   *          trackBy: trackItem;\n   *          parent: true;\n   *        \"\n   *      >\n   *        <div>{{ item.name }}</div>\n   *      </app-list-item>\n   *    </app-list-component>\n   *   `\n   * })\n   * export class AppComponent {\n   *   items$ = itemService.getItems();\n   * }\n   *\n   * @param {boolean} renderParent\n   */\n  renderParent = this.strategyProvider.config.parent;\n  /**\n   * @description\n   *\n   * A flag to control whether *rxFor templates are created within `NgZone` or not.\n   * The default value is `true, `*rxFor` will create it's `EmbeddedViews` inside `NgZone`.\n   *\n   * Event listeners normally trigger zone. Especially high frequently events cause performance issues.\n   *\n   * Read more about this in the\n   * [official docs](https://www.rx-angular.io/docs/template/api/rx-for-directive#working-with-event-listeners-patchzone).\n   *\n   * @example\n   * \\@Component({\n   *   selector: 'app-root',\n   *   template: `\n   *    <app-list-component>\n   *      <app-list-item\n   *        *rxFor=\"\n   *          let item of items$;\n   *          trackBy: trackItem;\n   *          patchZone: false;\n   *        \"\n   *      >\n   *        <div>{{ item.name }}</div>\n   *      </app-list-item>\n   *    </app-list-component>\n   *   `\n   * })\n   * export class AppComponent {\n   *   items$ = itemService.getItems();\n   * }\n   *\n   * @param {boolean} patchZone\n   */\n  patchZone = this.strategyProvider.config.patchZone;\n  /**\n   * @description\n   * A function or key that defines how to track changes for items in the iterable.\n   *\n   * When items are added, moved, or removed in the iterable,\n   * the directive must re-render the appropriate DOM nodes.\n   * To minimize churn in the DOM, only nodes that have changed\n   * are re-rendered.\n   *\n   * By default, rxFor assumes that the object instance identifies the node in the iterable (equality check `===`).\n   * When a function or key is supplied, rxFor uses the result to identify the item node.\n   *\n   * @example\n   * \\@Component({\n   *   selector: 'app-root',\n   *   template: `\n   *    <app-list-component>\n   *      <app-list-item\n   *        *rxFor=\"\n   *          let item of items$;\n   *          trackBy: 'id';\n   *        \"\n   *      >\n   *        <div>{{ item.name }}</div>\n   *      </app-list-item>\n   *    </app-list-component>\n   *   `\n   * })\n   * export class AppComponent {\n   *   items$ = itemService.getItems();\n   * }\n   *\n   * // OR\n   *\n   * \\@Component({\n   *   selector: 'app-root',\n   *   template: `\n   *    <app-list-component>\n   *      <app-list-item\n   *        *rxFor=\"\n   *          let item of items$;\n   *          trackBy: trackItem;\n   *        \"\n   *      >\n   *        <div>{{ item.name }}</div>\n   *      </app-list-item>\n   *    </app-list-component>\n   *   `\n   * })\n   * export class AppComponent {\n   *   items$ = itemService.getItems();\n   *   trackItem = (idx, item) => item.id;\n   * }\n   *\n   * @param trackByFnOrKey\n   */\n  set trackBy(trackByFnOrKey) {\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && trackByFnOrKey != null && typeof trackByFnOrKey !== 'string' && typeof trackByFnOrKey !== 'function') {\n      console.warn(`trackBy must be a function, but received ${JSON.stringify(trackByFnOrKey)}.`);\n    }\n    if (trackByFnOrKey == null) {\n      this._trackBy = null;\n    } else {\n      this._trackBy = typeof trackByFnOrKey !== 'function' ? (i, a) => a[trackByFnOrKey] : trackByFnOrKey;\n    }\n  }\n  /**\n   * @description\n   * A `Subject` which emits whenever *rxFor finished rendering a set changes to the view.\n   * This enables developers to perform actions when a list has finished rendering.\n   * The `renderCallback` is useful in situations where you rely on specific DOM properties like the `height` a\n   * table after all items got rendered.\n   * It is also possible to use the renderCallback in order to determine if a view should be visible or not. This\n   * way developers can hide a list as long as it has not finished rendering.\n   *\n   * The result of the `renderCallback` will contain the currently rendered set of items in the iterable.\n   *\n   * @example\n   * \\Component({\n   *   selector: 'app-root',\n   *   template: `\n   *   <app-list-component>\n   *     <app-list-item\n   *       *rxFor=\"\n   *         let item of items$;\n   *         trackBy: trackItem;\n   *         renderCallback: itemsRendered;\n   *       \">\n   *       <div>{{ item.name }}</div>\n   *     </app-list-item>\n   *   </app-list-component>\n   * `\n   * })\n   * export class AppComponent {\n   *   items$: Observable<Item[]> = itemService.getItems();\n   *   trackItem = (idx, item) => item.id;\n   *   // this emits whenever rxFor finished rendering changes\n   *   itemsRendered = new Subject<Item[]>();\n   *\n   *   constructor(elementRef: ElementRef<HTMLElement>) {\n   *     itemsRendered.subscribe(() => {\n   *       // items are rendered, we can now scroll\n   *       elementRef.scrollTo({bottom: 0});\n   *     })\n   *   }\n   * }\n   *\n   * @param {Subject<U>} renderCallback\n   */\n  set renderCallback(renderCallback) {\n    this._renderCallback = renderCallback;\n  }\n  get template() {\n    return this._template || this.templateRef;\n  }\n  /** @internal */\n  strategyInput$ = new ReplaySubject(1);\n  /** @internal */\n  observables$ = new ReplaySubject(1);\n  /** @internal */\n  _renderCallback;\n  /** @internal */\n  values$ = this.observables$.pipe(coerceObservableWith(), switchAll(), shareReplay({\n    refCount: true,\n    bufferSize: 1\n  }));\n  /** @internal */\n  values = null;\n  /** @internal */\n  strategy$ = this.strategyInput$.pipe(coerceDistinctWith());\n  /** @internal */\n  listManager;\n  /** @internal */\n  _subscription = new Subscription();\n  /** @internal */\n  _trackBy;\n  /** @internal */\n  _distinctBy = (a, b) => a === b;\n  /** @internal */\n  ngOnInit() {\n    this._subscription.add(this.values$.subscribe(v => this.values = v));\n    this.listManager = createListTemplateManager({\n      iterableDiffers: this.iterableDiffers,\n      renderSettings: {\n        cdRef: this.cdRef,\n        strategies: this.strategyProvider.strategies,\n        defaultStrategyName: this.strategyProvider.primaryStrategy,\n        parent: !!this.renderParent,\n        patchZone: this.patchZone ? this.ngZone : false,\n        errorHandler: this.errorHandler\n      },\n      templateSettings: {\n        viewContainerRef: this.viewContainerRef,\n        templateRef: this.template,\n        createViewContext: this.createViewContext.bind(this),\n        updateViewContext: this.updateViewContext.bind(this)\n      },\n      trackBy: this._trackBy\n    });\n    this.listManager.nextStrategy(this.strategy$);\n    this._subscription.add(this.listManager.render(this.values$).subscribe(v => this._renderCallback?.next(v)));\n  }\n  /** @internal */\n  createViewContext(item, computedContext) {\n    return new RxForViewContext(item, this.values, computedContext);\n  }\n  /** @internal */\n  updateViewContext(item, view, computedContext) {\n    view.context.updateContext(computedContext);\n    view.context.rxForOf = this.values;\n    view.context.$implicit = item;\n  }\n  /** @internal */\n  ngDoCheck() {\n    if (this.renderStatic) {\n      this.observables$.next(this.staticValue);\n    }\n  }\n  /** @internal */\n  ngOnDestroy() {\n    this._subscription.unsubscribe();\n    this.viewContainerRef.clear();\n  }\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  static ngTemplateContextGuard(dir, ctx) {\n    return true;\n  }\n  /** @nocollapse */\n  static ɵfac = function RxFor_Factory(t) {\n    return new (t || RxFor)();\n  };\n  /** @nocollapse */\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RxFor,\n    selectors: [[\"\", \"rxFor\", \"\", \"rxForOf\", \"\"]],\n    inputs: {\n      rxForOf: \"rxForOf\",\n      rxForTemplate: \"rxForTemplate\",\n      rxForStrategy: \"rxForStrategy\",\n      renderParent: [\"rxForParent\", \"renderParent\"],\n      patchZone: [\"rxForPatchZone\", \"patchZone\"],\n      trackBy: [\"rxForTrackBy\", \"trackBy\"],\n      renderCallback: [\"rxForRenderCallback\", \"renderCallback\"]\n    },\n    standalone: true\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RxFor, [{\n    type: Directive,\n    args: [{\n      selector: '[rxFor][rxForOf]',\n      standalone: true\n    }]\n  }], null, {\n    rxForOf: [{\n      type: Input\n    }],\n    rxForTemplate: [{\n      type: Input\n    }],\n    rxForStrategy: [{\n      type: Input\n    }],\n    renderParent: [{\n      type: Input,\n      args: ['rxForParent']\n    }],\n    patchZone: [{\n      type: Input,\n      args: ['rxForPatchZone']\n    }],\n    trackBy: [{\n      type: Input,\n      args: ['rxForTrackBy']\n    }],\n    renderCallback: [{\n      type: Input,\n      args: ['rxForRenderCallback']\n    }]\n  });\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { RxFor, RxForViewContext };\n"],
  "mappings": "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",
  "names": ["RxBaseTemplateNames"]
}
